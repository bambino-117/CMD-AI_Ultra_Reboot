# Plan de Route Stratégique pour CMD-AI_Ultra

## Version 0.1.0 : Le Point de Départ Actuel
* **Statut :** Distribuée aux testeurs en mode debug.
* **Fonctionnalités :** L'application de base avec ses fonctionnalités initiales (interface CLI, intégration LLM, etc.).

---

## Version 0.1.1 : Stabilité & Premiers Retours
* **Statut :** En cours de correction et d'implémentation.
* **Objectifs Principaux :**
    * **Correction de bugs :** Remonter et résoudre les bugs identifiés depuis la v0.1.0.
    * **Rapports d'erreurs automatisés :**
        * Implémentation des systèmes de rapport d'erreurs automatiques par E-mail (simple) et GitHub Issues.
        * Mise en place de la gestion centralisée des secrets (variables d'environnement avec `python-dotenv`).
        * Structure de code modulaire pour les systèmes de communication futurs.
    * **Améliorations de la robustesse :** Renforcement de la gestion des exceptions.
* **Faisabilité :** Très faisable et cruciale pour la qualité.

---

## Version 0.2.0 : Intégration & Confort Utilisateur
* **Statut :** Prochaine étape majeure.
* **Objectifs Principaux :**
    * **Détection matérielle :** Obtenir des informations sur l'environnement matériel.
    * **Installation Initiale :** Proposer à l'utilisateur de rentrer au moins une clé API lors de la première exécution.
    * **Expérience d'accueil améliorée :** Afficher un `README` ou un message de bienvenue clair lors de la première utilisation.
    * **Maintenance facilitée :** Commande/bouton pour vider les caches de l'application instantanément, suivi d'un rechargement.
    * **Audit interne :** Journalisation des accès aux fichiers ASCII (qui, quand, quoi).
    * **Communication Basique (Phase 2) :**
        * **Envoi d'E-mails étendu :** Permettre l'envoi d'e-mails général (avec gestion des pièces jointes).
        * **Messagerie Instantanée (Telegram) :** Implémentation de l'envoi de messages via l'API Bot de Telegram (la plus simple et stable).
    * **Export des conversations :** Possibilité d'enregistrer les conversations en PDF avec une mise en page basique.
* **Faisabilité :** Très faisable. Cette version apporte des améliorations significatives sans introduire de complexité architecturale majeure.

---

## Version 0.3.0 : Contrôle Avancé & Interopérabilité Fichier
* **Statut :** Planifiée après la v0.2.0.
* **Objectifs Principaux :**
    * **Contrôle du Système (Prérequis) :**
        * Obtention et gestion des privilèges administrateur par l'application (avec les défis liés à chaque OS). Cela débloque de nombreuses fonctionnalités futures.
    * **Flexibilité du Développement :**
        * Système de rechargement à chaud des commandes (utile pour les développeurs et la flexibilité de l'app).
    * **Communication Avancée :**
        * **Envoi d'E-mails Avancé :** Implémentation de l'intégration avec Exchange et IMAP pour l'envoi et la gestion des boîtes (y compris l'enregistrement dans les "éléments envoyés").
        * **Envoi d'E-mails "Anonymes" :** Exploration plus approfondie des mécanismes d'envoi anonyme (avec les limites et considérations légales).
        * **Messagerie Instantanée (Exploration) :** Étude et (si faisable et justifié) implémentation des intégrations WhatsApp (via API Business si possible) et Signal (via `signal-cli`).
    * **Gestion de Fichiers Intelligente :**
        * Capacité d'envoyer un fichier comme prompt, via messagerie, en pièce jointe d'email, ou vers un serveur distant (dépend des fonctionnalités de communication établies).
        * Système de verrouillage des fichiers ASCII pour minimiser la déformation et les accès concurrents.
* **Faisabilité :** Faisable, mais nécessite une attention particulière aux spécificités OS pour les privilèges admin et la complexité des API de messagerie avancées.

---

## Version 0.4.0 : Services Réseau & Déploiement
* **Statut :** Planifiée après la v0.3.0.
* **Objectifs Principaux :**
    * **Utilitaires Système :**
        * Intégration d'une fonction de capture d'écran (similaire à l'outil Windows, adaptée à une CLI).
    * **Déploiement Windows :**
        * Rendre l'application installable avec inscription sur le registre Windows (pour une meilleure intégration au système).
    * **Interaction Réseau Local :**
        * Capacité d'envoyer une alerte push à tous les appareils sur le même réseau, avec journalisation des envois.
        * Offrir la possibilité de créer et donner accès à un serveur distant simple (ex: HTTP/FTP temporaire) avec génération automatique d'un texte "how-to?".
    * **Monitoring de base :**
        * Mise en place d'une instrumentation de base pour une "plateforme de suivi" (envoyer des métriques simples vers un système externe si disponible, ou logs structurés).
* **Faisabilité :** Faisable, mais certains points réseau et OS sont complexes et nécessitent une bonne compréhension des protocoles.

---

## Version 1.0.0+ : Refonte Architecturale & Fonctionnalités de Pointe
* **Statut :** Futures versions majeures.
* **Objectifs Principaux :** Ces fonctionnalités sont des projets majeurs qui pourraient nécessiter une refonte architecturale ou l'ajout de composants serveur dédiés.
    * **Communication User-to-User :**
        * Fonction de messages directs de user à user, avec attribution d'un numéro d'immatriculation. Cela implique une **infrastructure serveur backend** pour la gestion des utilisateurs, l'authentification, le routage des messages, la persistance des données, et une sécurité de haut niveau.
    * **Auto-Réparation Avancée :**
        * Capacité de l'application à réparer ses propres erreurs (au-delà des simples configurations). Cela nécessiterait une IA avancée capable d'analyser les logs, de diagnostiquer les problèmes et d'appliquer des correctifs, ou des scénarios de récupération très spécifiques.
    * **Cross-Platform Étendue :**
        * Extension à des plateformes mobiles (iOS, Android). Cela signifierait passer d'une CLI pure à une application avec une interface graphique (GUI) spécifique aux mobiles, nécessitant des frameworks comme Kivy ou BeeWare, ou même un développement natif/hybride.
* **Faisabilité :** Très complexe et exige des ressources et un temps de développement considérables.


=============================================================================

# Dans la classe LanguageModelHandler
def process_command(self, command_text):
    # ... (votre logique pour router la commande ou interagir avec le LLM) ...
    try:
        # Exemple d'appel à une fonction LLM
        if self.default_lm_name == "openai":
            response = self._openai_llm.generate_response(command_text)
        elif self.default_lm_name == "gemini":
            response = self._gemini_llm.get_response(command_text)
        # ... autres LLM
        return response
    except Exception as e:
        error_msg = str(e)
        context = f"Erreur lors du traitement de la commande/requête LLM: '{command_text}' avec {self.default_lm_name}"
        # --- AJOUT ICI ---
        report_error(error_msg, context)
        # ---------------
        logging.error(f"Erreur LLM dans process_command : {e}", exc_info=True)
        raise # Re-lancer l'exception pour que l'interface puisse la gérer et afficher un message à l'utilisateur
		
============================================================================
Brouillon de Fichier README.md
Ce README.md peut servir de base pour votre dépôt GitHub. Il met en avant les points forts de votre application et donne les instructions de base.
# CMD-AI Ultra

![Python](https://img.shields.io/badge/Python-3.9+-blue?style=flat-square&logo=python)
![CustomTkinter](https://img.shields.io/badge/UI-CustomTkinter-green?style=flat-square&logo=tkinter)
![LLM](https://img.shields.io/badge/AI-LLMs-orange?style=flat-square&logo=openai)
![Version](https://img.shields.io/badge/Version-0.1.1--beta-red?style=flat-square)

---

## À Propos de CMD-AI Ultra

CMD-AI Ultra est une application hybride (interface en ligne de commande et graphique) conçue pour interagir de manière fluide avec divers modèles de langage (LLM) et offrir une gestion avancée des commandes système et des communications. Notre objectif est de fournir un outil puissant et personnalisable pour les utilisateurs recherchant une interaction intelligente avec leur environnement numérique.

## Fonctionnalités Actuelles (v0.1.1-beta)

* **Interface Intuitive :** Une interface utilisateur graphique (GUI) développée avec CustomTkinter pour une expérience moderne, couplée à une robustesse en ligne de commande.
* **Intégration LLM :** Support initial pour l'intégration avec plusieurs modèles de langage (OpenAI, Gemini, Mistral, DeepSeek, Hugging Face - GPT-2 local).
* **Système de Commandes Modulaire :** Un parseur de commandes et un chargeur de commandes permettant d'étendre facilement les capacités de l'application.
* **Gestion de Configuration :** Chargement et sauvegarde des paramètres de l'application.
* **Rapports d'Erreurs Automatisés :** Envoi automatique des rapports d'erreurs par e-mail et/ou création de GitHub Issues pour une meilleure qualité logicielle et un suivi rapide des problèmes.
* **Journalisation (Logging) :** Enregistrement détaillé des activités et des erreurs pour un débogage efficace.

## Installation

### Prérequis

* Python 3.9 ou plus récent.
* Git (pour cloner le dépôt).

### Étapes d'Installation

1.  **Cloner le dépôt :**
    ```bash
    git clone [https://github.com/bambino-117/CMD-AI_Ultra.git](https://github.com/bambino-117/CMD-AI_Ultra.git)
    cd CMD-AI_Ultra
    ```

2.  **Créer et activer un environnement virtuel (recommandé) :**
    ```bash
    python -m venv venv
    # Sur Windows
    .\venv\Scripts\activate
    # Sur macOS / Linux
    source venv/bin/activate
    ```

3.  **Installer les dépendances :**
    ```bash
    pip install -r requirements.txt
    ```
    *(Note : Assurez-vous d'avoir un fichier `requirements.txt` listant toutes vos dépendances comme `customtkinter`, `PyGithub`, `python-dotenv`, `requests`, `openai`, etc.)*

4.  **Configuration des Clés API (Très Important !) :**
    Pour des raisons de sécurité, les clés API **ne doivent pas** être stockées directement dans les fichiers de configuration. Créez un fichier nommé `.env` à la racine du projet et ajoutez vos clés API comme suit :

    ```
    OPENAI_API_KEY="sk-votre_cle_openai_ici"
    GEMINI_API_KEY="votre_cle_gemini_ici"
    MISTRAL_API_KEY="votre_cle_mistral_ici"
    DEEPSEEK_API_KEY="votre_cle_deepseek_ici"
    GITHUB_TOKEN="ghp_votre_token_github_ici"
    SMTP_PASSWORD="votre_mot_de_passe_smtp_ici"
    # Ajoutez d'autres clés API ou mots de passe nécessaires
    ```
    **Ne committez jamais le fichier `.env` sur Git !** Assurez-vous qu'il est inclus dans votre `.gitignore`.

## Utilisation

Pour lancer l'application :

```bash
python main.py


===========================================================================
.
├── core/
│   ├── config.py             # Gestion des paramètres de l'application
│   ├── dispatcher.py         # Logique de routage des commandes et interaction LLM
│   ├── resource_manager.py   # (Si existant, gestion des ressources)
├── ui/
│   ├── interface.py          # Interface utilisateur graphique (CustomTkinter)
│   ├── error_reporter.py     # Module pour l'envoi automatisé des rapports d'erreurs
├── ressources/
│   ├── command_loader.py     # Chargeur de définitions de commandes
│   ├── command_parser.py     # Analyseur d'entrée utilisateur en commandes
│   ├── file_watcher.py       # (Si existant, surveillance de fichiers)
├── logs/
│   └── app.log               # Fichiers de log de l'application
├── config.json               # Configuration par défaut (peut être fusionnée avec user_settings.json)
├── user_settings.json        # Paramètres utilisateur (API keys à migrer vers .env)
├── main.py                   # Point d'entrée principal de l'application
├── .env                      # **À CRÉER** - Contient les clés API et secrets (NON COMMITTER)
├── .gitignore                # Fichiers et dossiers à ignorer par Git
├── requirements.txt          # Liste des dépendances Python
└── README.md                 # Ce fichier

Contribution
Nous accueillons les contributions ! Veuillez lire nos directives de contribution (à venir) pour plus d'informations.

Licence
Ce projet est sous licence [Nom de la Licence, ex: MIT]. Voir le fichier LICENSE pour plus de détails.

# Feuille de Route - CMD-AI Ultra v1.1.1 : Améliorations de l'Interface et Outils Réseau Interactifs

**Objectif principal :** Améliorer l'expérience utilisateur grâce à des menus contextuels interactifs pour les outils réseau et une meilleure gestion des états de l'application, ainsi que l'intégration de la fonctionnalité de rapport de bugs automatique.

==========================================================================
--------------------------------------------------------------------------
==========================================================================

### 1. Améliorations de l'Interface Utilisateur (UI)

#### 1.1. Gestion des États et Menus Contextuels

* **Description :** Implémentation d'un système d'états pour l'interface (`self.current_state` et `self.state_history`) permettant des interactions guidées via des menus textuels dynamiques et la possibilité de revenir en arrière.
* **Fichier concerné :** `ui/interface.py`
* **Modifications clés :**
    * **Attributs d'état :**
        ```python
        # ui/interface.py dans __init__
        self.current_state = "IDLE" # États possibles: IDLE, NETWORK_MENU, AWAITING_TRACE_DEST, ...
        self.state_history = []     # Pile pour l'historique des états
        self.network_menu_options = { # Options pour le menu principal réseau
            "1": "Info Réseau (netinfo)",
            "2": "Traceroute (trace)",
            # "3": "Scan Local (À venir)",
            # "4": "Diagnostic Ping (À venir)",
        }
        ```
    * **Logique de traitement de l'entrée (`_process_user_input`) :**
        ```python
        # ui/interface.py
        def _process_user_input(self, user_input: str):
            response = ""
            user_input_lower = user_input.lower()

            # GESTION DES COMMANDES DE NAVIGATION DE MENU
            if user_input_lower == "back":
                if self.state_history:
                    self.current_state = self.state_history.pop()
                    self._display_current_menu_or_idle_message()
                    return
                else:
                    self.text_area.insert_text("Vous êtes déjà au niveau le plus élevé.", "system_message")
                    self.current_state = "IDLE"
                    return
            
            if user_input_lower == "exit_menu" or user_input_lower == "quit":
                self.state_history.clear()
                self.current_state = "IDLE"
                self.text_area.insert_text("Vous avez quitté le mode menu.", "system_message")
                self.text_area.insert_text(self.placeholder_text, "placeholder_text")
                return

            # GESTION DES ÉTATS ET DES MENUS
            if self.current_state == "NETWORK_MENU":
                self._handle_network_menu_choice(user_input)
                return
            elif self.current_state == "AWAITING_TRACE_DEST":
                self.state_history.pop() 
                self.current_state = "IDLE" 
                self._execute_command_and_display(f"trace {user_input}")
                return
            
            # GESTION DES COMMANDES PRINCIPALES
            if user_input_lower == "network":
                self._push_state("IDLE") 
                self.current_state = "NETWORK_MENU"
                self._display_network_menu()
            elif user_input_lower.startswith("trace "):
                self._execute_command_and_display(user_input)
            elif user_input_lower == "netinfo":
                self._execute_command_and_display(user_input)
            elif user_input_lower == "help":
                self._show_help()
            elif user_input_lower.startswith("aide "):
                self._show_specific_help(user_input_lower.split(" ", 1)[1])
            else:
                self._execute_command_and_display(user_input)
        ```
    * **Fonctions d'aide à la navigation des menus :**
        ```python
        # ui/interface.py
        def _push_state(self, state: str):
            self.state_history.append(state)

        def _display_current_menu_or_idle_message(self):
            if self.current_state == "NETWORK_MENU":
                self._display_network_menu()
            elif self.current_state == "IDLE":
                self.text_area.insert_text("Revenu au menu principal.", "system_message")
                self.text_area.insert_text(self.placeholder_text, "placeholder_text")
            else:
                self.text_area.insert_text(f"État inconnu ou sans menu direct: {self.current_state}", "system_message")

        def _display_network_menu(self):
            menu_text = "\n--- Menu Outils Réseau ---\n"
            for num, option in self.network_menu_options.items():
                menu_text += f"{num}. {option}\n"
            menu_text += "Entrez le numéro de votre choix ou 'back'/'exit_menu' pour quitter.\n"
            menu_text += "--------------------------\n"
            self.text_area.insert_text(menu_text, "system_message")

        def _handle_network_menu_choice(self, choice: str):
            if choice == "1": # Info Réseau
                self._execute_command_and_display("netinfo")
                self._push_state("NETWORK_MENU") 
                self.current_state = "NETWORK_MENU" 
                self._display_network_menu() 
            elif choice == "2": # Traceroute
                self._push_state("NETWORK_MENU") 
                self.current_state = "AWAITING_TRACE_DEST"
                self.text_area.insert_text("Veuillez entrer l'adresse IP ou le nom d'hôte pour le traceroute :", "system_message")
            else:
                self.text_area.insert_text("Choix invalide. Veuillez entrer un numéro valide ou 'back'/'exit_menu'.", "error_red")
                self._display_network_menu()
        ```
* **Requêtes/Commandes utilisateur :**
    * `network` : Affiche le menu principal des outils réseau.
    * `1` (après `network`) : Exécute `netinfo` et réaffiche le menu réseau.
    * `2` (après `network`) : Demande une destination pour `trace`.
    * `<destination>` (après `2`) : Exécute `trace <destination>`.
    * `back` : Revient au menu ou à l'état précédent.
    * `exit_menu` ou `quit` : Sort de tout mode menu et revient à l'état `IDLE`.

#### 1.2. Amélioration de `CustomTextArea` pour les liens

* **Description :** Ajout de la capacité à insérer des liens cliquables dans le `CustomTextArea` pour des URLs comme les rapports de bugs.
* **Fichier concerné :** `ui/interface.py`
* **Modifications clés :**
    ```python
    # ui/interface.py dans CustomTextArea
    class CustomTextArea(scrolledtext.ScrolledText):
        def __init__(self, *args, **kwargs):
            super().__init__(*args, **kwargs)
            # ... tags existants ...
            self.tag_configure("link", foreground=COLORS["link"], underline=True)
            self.tag_bind("link", "<Button-1>", self._on_link_click)
            self.links = {} # Stores (start_index, end_index): url_value for link clicks

        def _on_link_click(self, event):
            for tag_range, url in self.links.items():
                start_index_str, end_index_str = tag_range
                try:
                    if self.tag_names(tk.CURRENT) and "link" in self.tag_names(tk.CURRENT):
                        webbrowser.open(url)
                        break
                except Exception as e:
                    logger.error(f"Erreur lors de l'ouverture du lien {url}: {e}")

        def insert_link(self, text, url):
            self.config(state='normal')
            start_index = self.index(tk.END)
            self.insert(tk.END, text, "link")
            end_index = self.index(tk.END)
            self.links[(start_index, end_index)] = url
            self.insert(tk.END, "\n") 
            self.config(state='disabled')
            self.see(tk.END)
    ```
* **Utilisation (exemple dans `_report_bug`) :**
    ```python
    # ui/interface.py dans _report_bug
    def _report_bug(self):
        report_url = "[https://github.com/Florian-DELAVOIPERE/CMD-AI-Ultra/issues/new](https://github.com/Florian-DELAVOIPERE/CMD-AI-Ultra/issues/new)"
        self.text_area.insert_text(f"Veuillez signaler votre bug ici: {report_url}", "system_message")
        self.text_area.insert_link("Ouvrir le lien de rapport de bug", report_url)
        webbrowser.open(report_url)
    ```

#### 1.3. Affichage du `placeholder_text`

* **Description :** Amélioration de la gestion du texte d'indication dans le champ d'entrée, y compris sa couleur.
* **Fichier concerné :** `ui/interface.py`
* **Modifications clés :**
    ```python
    # ui/interface.py dans __init__
    self.placeholder_text = "Tapez votre commande ou question ici (ex: 'aide', 'trace google.com', 'network')..."
    self.input_entry.bind("<FocusIn>", self._on_entry_focus_in)
    self.input_entry.bind("<FocusOut>", self._on_entry_focus_out)
    self._on_entry_focus_out(None) # Set initial placeholder

    # ui/interface.py nouvelles méthodes
    def _on_entry_focus_in(self, event):
        if self.input_entry.get() == self.placeholder_text:
            self.input_entry.delete(0, tk.END)
            self.input_entry.config(foreground=COLORS["text"]) 

    def _on_entry_focus_out(self, event):
        if not self.input_entry.get():
            self.input_entry.insert(0, self.placeholder_text)
            self.input_entry.config(foreground=COLORS["placeholder_text"]) 
    ```

#### 1.4. Couleurs de texte enrichies

* **Description :** Ajout de tags de couleur pour les messages système, l'entrée utilisateur, les réponses LLM, les erreurs et les sorties de commande.
* **Fichier concerné :** `ui/interface.py`
* **Modifications clés :**
    ```python
    # ui/interface.py en haut du fichier
    COLORS = {
        "background": "#F0F0F0",
        "text": "#000000",
        "link": "#0000FF",
        "placeholder_text": "#A0A0A0",
        "system_message": "#808080", # Gris pour les messages système/menus
        "user_input": "#00008B",     # Bleu foncé pour l'input utilisateur
        "llm_response": "#006400",   # Vert foncé pour les réponses LLM
        "error_red": "#FF0000",      # Rouge pour les erreurs
        "command_output": "#4682B4"  # Bleu acier pour la sortie des commandes
    }

    # ui/interface.py dans CustomTextArea.__init__
    self.tag_configure("system_message", foreground=COLORS["system_message"])
    self.tag_configure("user_input", foreground=COLORS["user_input"])
    self.tag_configure("llm_response", foreground=COLORS["llm_response"])
    self.tag_configure("error_red", foreground=COLORS["error_red"])
    self.tag_configure("command_output", foreground=COLORS["command_output"])
    ```
* **Utilisation :**
    * `self.text_area.insert_text("message", "system_message")`
    * `self.text_area.insert_text(f"> {user_input}", "user_input")`
    * Les réponses LLM devront être taguées "llm_response" par le `Dispatcher`.
    * Les erreurs "error_red".
    * Les sorties de commande "command_output".

### 2. Outils Réseau Intégrés

#### 2.1. Commande `netinfo`

* **Description :** Affiche les informations réseau de base de la machine.
* **Fichiers concernés :** `ui/interface.py`, `core/dispatcher.py` (assurez-vous que le dispatcher peut exécuter cette commande).
* **Requête utilisateur :** `netinfo`
* **Implémentation dans `Dispatcher` (Mock example) :**
    ```python
    # core/dispatcher.py (Exemple de mock pour le test)
    def dispatch_command(self, user_input: str) -> str:
        # ... (autres commandes) ...
        elif user_input_lower == "netinfo":
            return self.get_network_info() # Appelle une méthode dédiée
        # ...

    def get_network_info(self) -> str:
        # Ceci serait la vraie implémentation, utilisant si possible SystemInfoManager
        # Pour l'instant, c'est un mock
        return "--- Mock Informations Réseau ---\nAdresses IP:\n  Eth0: 192.168.1.10/24\n  Lo: 127.0.0.1/8\nPasserelle par défaut:\n  192.168.1.1\nServeurs DNS:\n  8.8.8.8\n  1.1.1.1\n--- Fin Mock Informations Réseau ---"
    ```

#### 2.2. Commande `trace <destination>`

* **Description :** Exécute un traceroute vers une destination spécifiée.
* **Fichiers concernés :** `ui/interface.py`, `core/dispatcher.py` (assurez-vous que le dispatcher peut exécuter cette commande).
* **Requête utilisateur :** `trace google.com` ou `trace 8.8.8.8`
* **Implémentation dans `Dispatcher` (Mock example) :**
    ```python
    # core/dispatcher.py (Exemple de mock pour le test)
    def dispatch_command(self, user_input: str) -> str:
        if user_input_lower.startswith("trace "):
            target = user_input_lower.split(" ", 1)[1]
            return f"Mock Traceroute vers {target}:\n1  <1 ms  1 ms  1 ms  router.local\n2  10 ms 12 ms 11 ms  isp.gateway\n..."
        # ... (autres commandes) ...
    ```

### 3. Gestion des Mises à Jour

* **Description :** Intégration d'un système de vérification et de téléchargement de mises à jour au démarrage et via un menu.
* **Fichiers concernés :** `ui/interface.py`, `core/update_manager.py`
* **Modifications clés dans `interface.py` :**
    ```python
    # ui/interface.py dans __init__
    from core.update_manager import UpdateManager # NOUVEL IMPORT

    CURRENT_APP_VERSION = "0.1.1" # Mettre à jour à chaque nouvelle version
    UPDATE_INFO_URL = "[https://raw.githubusercontent.com/Florian-DELAVOIPERE/CMD-AI-Ultra/main/update_info.json](https://raw.githubusercontent.com/Florian-DELAVOIPERE/CMD-AI-Ultra/main/update_info.json)" # URL du fichier JSON de mise à jour
    DOWNLOAD_DIR = "updates" # Répertoire pour les téléchargements de mise à jour

    # Vérification de mise à jour au démarrage dans un thread séparé
    threading.Thread(target=self._check_for_updates_on_startup).start()

    # ui/interface.py fonctions pour les mises à jour
    def _check_for_updates_on_startup(self):
        update_manager = UpdateManager(CURRENT_APP_VERSION, UPDATE_INFO_URL, DOWNLOAD_DIR)
        update_available, latest_version, download_url = update_manager.check_for_update()
        if update_available:
            msg = f"Une nouvelle version ({latest_version}) est disponible. Voulez-vous la télécharger maintenant ?"
            if tkmb.askyesno("Mise à jour disponible", msg):
                threading.Thread(target=self._download_and_apply_update, args=(update_manager, latest_version, download_url)).start()
            else:
                self.text_area.insert_text("Mise à jour annulée par l'utilisateur.", "system_message")
        else:
            self.text_area.insert_text("Votre application est à jour.", "system_message")

    def _download_and_apply_update(self, update_manager, latest_version, download_url):
        downloaded_path = update_manager.download_update(download_url, latest_version)
        if downloaded_path:
            tkmb.showinfo("Mise à jour", "La mise à jour va être appliquée. L'application va se fermer et redémarrer.")
            update_manager.apply_update_and_restart(downloaded_path)
        else:
            tkmb.showerror("Erreur de mise à jour", "Échec du téléchargement de la mise à jour.")
    
    # ... et la fonction _check_for_updates pour le menu ...
    ```
* **Fichier `update_info.json` (exemple sur GitHub) :**
    ```json
    {
        "version": "1.1.1",
        "download_url": "[https://github.com/Florian-DELAVOIPERE/CMD-AI-Ultra/releases/download/v1.1.1/CMD-AI-Ultra_v1.1.1.zip](https://github.com/Florian-DELAVOIPERE/CMD-AI-Ultra/releases/download/v1.1.1/CMD-AI-Ultra_v1.1.1.zip)",
        "release_notes": "Correction de bugs, amélioration de l'interface, outils réseau interactifs."
    }
    ```
* **Requêtes utilisateur :**
    * (Automatique au démarrage)
    * Menu `Outils` -> `Vérifier les Mises à jour`

### 4. Rapports de Bugs Automatisés (avec `traceback.py`)

* **Description :** Intégration de la fonction de rapport de bugs automatique pour envoyer les erreurs critiques vers GitHub.
* **Fichiers concernés :** `ui/interface.py`, `traceback.py` (module séparé).
* **Modifications clés dans `interface.py` :**
    * Ajout de `_report_bug` à la barre de menus.
    * Appel de `send_error_report` depuis le module `traceback` en cas d'erreur non gérée (ceci nécessiterait d'envelopper les blocs critiques dans des `try-except` plus généraux pour capturer ces erreurs et les envoyer).

    ```python
    # ui/interface.py dans _setup_menu
    help_menu.add_command(label="Signaler un bug", command=self._report_bug)

    # ui/interface.py (la fonction _report_bug a été détaillée plus haut)

    # Pour une intégration complète, il faudrait un try-except autour de la boucle principale
    # dans main.py ou autour des handlers de commande dans dispatcher.py
    # Exemple (conceptuel) :
    # import traceback_module # Assurez-vous d'avoir le bon chemin
    # try:
    #     # Votre code qui peut générer une erreur
    #     result = some_risky_operation()
    # except Exception as e:
    #     error_message = str(e)
    #     context_info = "Contexte de la commande, arguments, état de l'app..."
    #     stack_trace = traceback.format_exc()
    #     traceback_module.send_error_report(error_message, context_info, stack_trace)
    #     self.text_area.insert_text(f"Une erreur critique est survenue: {e}\nUn rapport de bug a été envoyé.", "error_red")
    ```

* **Requête utilisateur :**
    * Menu `Aide` -> `Signaler un bug` (ou déclenchement automatique en cas d'erreur critique).

---

### 5. Intégration et Déploiement

* **Mise à jour des versions :** Mettre à jour `CURRENT_APP_VERSION` dans `ui/interface.py` à `"1.1.1"`.
* **Tests :** Effectuer des tests rigoureux des nouvelles fonctionnalités de menu, des outils réseau, des mises à jour et des rapports de bugs.
* **Documentation :** Mettre à jour la documentation utilisateur (guide, README) pour refléter les nouvelles commandes et interactions.
* **Build :** Générer une nouvelle version de l'application packagée (ex: avec PyInstaller) et la mettre à disposition.

---

# Feuille de Route - CMD-AI Ultra v1.2.0 : Moteur Multimédia et Refonte UI/UX "Media Hub"

**Objectif principal :** Intégrer un lecteur multimédia complet (audio/vidéo/image) via une nouvelle interface utilisateur au design distinct, détaché de l'esthétique système, et offrir une expérience utilisateur renouvelée avec des éléments UI interactifs.

---

### 1. Développement du "Media Hub" (Nouvelle Interface Multimédia)

#### 1.1. Conception et Implémentation de l'Interface "Media Hub"

* **Description :** Création d'une nouvelle fenêtre ou d'un nouveau cadre pour le lecteur multimédia, avec un design graphique spécifique et distinct de l'interface principale de CMD-AI Ultra.
* **Fichiers concernés :**
    * `ui/media_hub_interface.py` (nouveau module)
    * `ui/interface.py` (pour le bouton/commande d'accès au Media Hub)
    * `core/config.py` (pour de nouveaux paramètres de couleur/police spécifiques au Media Hub si nécessaire)
* **Spécifications du Design :**
    * **Polices :** Taille 8, famille Tahoma, couleur blanc-grisâtre.
    * **Fond :** Noir-grisâtre uni.
    * **Encadrement :** Coins arrondis à quelques pixels des bords de la fenêtre, couleur potentiellement blanc-grisâtre ou une nuance plus claire du fond.
    * **Boutons de fenêtre (Fermer, Réduire, Minimiser) :** Style personnalisé, non encadrés, intégrés au header avec le même style de police et des effets de clic visuels.
    * **Header Titre :** Utilisation de la même police et couleur, avec un style minimaliste.
    * **Champ de Saisie :** Intégré à la zone de texte sans séparation visuelle (un `CustomTextArea` adapté pourrait servir).
    * **Boutons additionnels (lecture, pause, suivant, etc.) :** Titres cliquables sans cadre, avec des effets de survol et de clic visuels (changement de couleur, légère animation).

* **Code Conceptuel (Exemple de structure `media_hub_interface.py`) :**

    ```python
    # ui/media_hub_interface.py (Nouveau Fichier)
    import tkinter as tk
    from tkinter import scrolledtext # Peut être adapté pour le champ de saisie intégré
    import vlc # Exemple pour le lecteur multimédia (nécessitera une installation)

    class MediaHubInterface(tk.Toplevel): # Utilisation de Toplevel pour une nouvelle fenêtre
        def __init__(self, master=None):
            super().__init__(master)
            self.title("CMD-AI Ultra - Media Hub")
            self.geometry("800x600")
            self.overrideredirect(True) # Supprime la barre de titre par default (pour les boutons custom)
            self._setup_custom_ui()
            self._setup_media_player()

            # Attributs pour le glisser-déposer de la fenêtre custom
            self._offset_x = 0
            self._offset_y = 0
            self.bind("<Button-1>", self._start_move)
            self.bind("<B1-Motion>", self._on_move)

        def _setup_custom_ui(self):
            # Fond et encadrement
            self.configure(bg="#2E2E2E") # Noir-grisâtre
            
            # Cadre principal avec coins arrondis (nécessitera du canvas ou une image de fond)
            # Pour l'instant, on simule avec un cadre simple
            main_frame = tk.Frame(self, bg="#2E2E2E", bd=2, relief="solid", highlightbackground="#CCCCCC", highlightthickness=1)
            main_frame.pack(fill="both", expand=True, padx=5, pady=5)
            
            # Header personnalisé
            header_frame = tk.Frame(main_frame, bg="#2E2E2E")
            header_frame.pack(fill="x", side="top", pady=(0, 5))

            self.title_label = tk.Label(header_frame, text="CMD-AI Ultra - Media Hub", font=("Tahoma", 8), fg="white", bg="#2E2E2E")
            self.title_label.pack(side="left", padx=10, pady=5)

            # Boutons custom (Fermer, Réduire, Minimiser)
            # Ils devront être implémentés avec des événements de clic et des images/textes
            # Pour l'exemple, des labels cliquables
            close_btn = tk.Label(header_frame, text="x", font=("Tahoma", 8, "bold"), fg="white", bg="#2E2E2E", cursor="hand2")
            close_btn.pack(side="right", padx=5)
            close_btn.bind("<Button-1>", lambda e: self.destroy())
            
            minimize_btn = tk.Label(header_frame, text="_", font=("Tahoma", 8, "bold"), fg="white", bg="#2E2E2E", cursor="hand2")
            minimize_btn.pack(side="right")
            minimize_btn.bind("<Button-1>", lambda e: self.iconify()) # Minimiser

            # Zone de contenu (pour le lecteur, les infos, etc.)
            content_frame = tk.Frame(main_frame, bg="#3A3A3A") # Une nuance légèrement différente
            content_frame.pack(fill="both", expand=True)

            # Espace pour le lecteur multimédia (vidéo ou image)
            self.media_canvas = tk.Canvas(content_frame, bg="black", highlightthickness=0)
            self.media_canvas.pack(fill="both", expand=True, padx=10, pady=10)

            # Champ de saisie / zone de texte sans séparation (exemple rudimentaire)
            self.info_text_area = scrolledtext.ScrolledText(content_frame, wrap="word", height=5, font=("Tahoma", 8), fg="white", bg="#3A3A3A", insertbackground="white", bd=0, relief="flat")
            self.info_text_area.pack(fill="x", padx=10, pady=(0, 10))
            self.info_text_area.insert(tk.END, "Informations sur le média / Zone de saisie...")
            self.info_text_area.config(state="disabled") # Rendre non éditable par défaut

            # Boutons de contrôle multimédia (ex: "Lecture", "Pause")
            control_frame = tk.Frame(main_frame, bg="#2E2E2E")
            control_frame.pack(fill="x", side="bottom", pady=(5, 0))

            play_button_label = tk.Label(control_frame, text="Lecture", font=("Tahoma", 8), fg="white", bg="#2E2E2E", cursor="hand2")
            play_button_label.pack(side="left", padx=10)
            play_button_label.bind("<Button-1>", self._play_media)
            # Ajouter des effets de hover/click via des événements de souris

        def _start_move(self, event):
            self._offset_x = event.x
            self._offset_y = event.y

        def _on_move(self, event):
            x = self.winfo_x() + event.x - self._offset_x
            y = self.winfo_y() + event.y - self._offset_y
            self.geometry(f"+{x}+{y}")

        def _setup_media_player(self):
            # Logique d'initialisation du lecteur VLC ou autre bibliothèque
            # self.instance = vlc.Instance()
            # self.player = self.instance.media_player_new()
            pass # À implémenter

        def _play_media(self, event=None):
            # Logique de lecture d'un média
            self.info_text_area.config(state="normal")
            self.info_text_area.delete(1.0, tk.END)
            self.info_text_area.insert(tk.END, "Lancement du média...")
            self.info_text_area.config(state="disabled")
            # self.player.set_media(self.instance.media_new("path/to/media.mp4"))
            # self.player.play()

        # D'autres méthodes pour gérer les différents types de médias, la progression, etc.
    ```

#### 1.2. Fonctionnalités du Lecteur Multimédia

* **Description :** Intégration des capacités de lecture pour différents formats de fichiers.
* **Bibliothèques potentielles :**
    * **Audio/Vidéo :** `python-vlc` (nécessite l'installation de VLC), `moviepy` (pour le traitement, pas la lecture directe mais utile), `ffpyplayer`.
    * **Image :** `Pillow (PIL)`, `OpenCV` (si des traitements avancés sont nécessaires).
* **Capacités requises :**
    * Lecture/Pause/Stop.
    * Avance/Retour rapide.
    * Contrôle du volume.
    * Affichage de la progression.
    * Support des formats courants (MP3, WAV, MP4, AVI, JPG, PNG, GIF).
    * Gestion des playlists (pour audio/vidéo).
    * Affichage des métadonnées (titre, artiste, durée, etc.).

#### 1.3. Intégration à l'Interface Principale

* **Description :** Ajout d'une commande et/ou d'un bouton dans l'interface principale (`interface.py`) pour lancer le "Media Hub".
* **Fichier concerné :** `ui/interface.py`
* **Code Conceptuel :**

    ```python
    # ui/interface.py dans _setup_menu ou dans _process_user_input
    from ui.media_hub_interface import MediaHubInterface # Nouvel import

    def _open_media_hub(self):
        # Créer et afficher la nouvelle fenêtre Media Hub
        # S'assurer qu'une seule instance est ouverte à la fois
        if not hasattr(self, '_media_hub_window') or not self._media_hub_window.winfo_exists():
            self._media_hub_window = MediaHubInterface(self)
        self._media_hub_window.lift() # Mettre la fenêtre au premier plan

    # Dans _process_user_input:
    # elif user_input_lower == "media":
    #     self._open_media_hub()

    # Dans _setup_menu:
    # media_menu = Menu(menubar, tearoff=0)
    # menubar.add_cascade(label="Média", menu=media_menu)
    # media_menu.add_command(label="Ouvrir Media Hub", command=self._open_media_hub)
    ```
* **Requêtes utilisateur :**
    * `media` (commande dans l'interface principale)
    * Menu `Média` -> `Ouvrir Media Hub`

### 2. Refonte des Éléments UI/UX de l'Interface Principale (Optionnel / Future étape)

* **Description :** Appliquer certains principes de design du "Media Hub" à l'interface principale, notamment pour les boutons.
* **Considérations :** Cette étape pourrait être scindée en une v1.3.0 pour ne pas surcharger la v1.2.0 déjà ambitieuse avec l'intégration multimédia.
* **Éléments à considérer :**
    * **Boutons `Envoyer` et autres :** Passer de `ttk.Button` à des `tk.Label` stylisés avec des effets de clic, ou utiliser un framework comme `customtkinter` qui offre plus de flexibilité de style.
    * **Champs de saisie :** Affiner l'intégration visuelle du champ de saisie avec la zone de texte pour une apparence plus unifiée.
    * **Thème Général :** Revoir la palette de couleurs et les espacements pour une esthétique plus cohérente avec le nouveau Media Hub.

### 3. Aspects Techniques et Déploiement

* **Gestion des Dépendances :** Identification et ajout des bibliothèques nécessaires (`python-vlc`, `Pillow`, etc.) au `requirements.txt`.
* **Installation de VLC :** Notifier l'utilisateur de la nécessité d'installer VLC séparément si `python-vlc` est utilisé.
* **Performances :** Optimisation pour assurer une lecture fluide et une interface réactive.
* **Tests Multimédia :** Tester la lecture de divers formats et la stabilité de l'interface.
* **Documentation :** Mettre à jour la documentation pour inclure l'utilisation du Media Hub et ses fonctionnalités.
* **Mise à jour de Version :** Passer `CURRENT_APP_VERSION` à `"1.2.0"` dans `ui/interface.py`.