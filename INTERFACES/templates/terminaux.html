<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Mégastructure // Terminal Actif</title>
    <link rel="icon" href="data:;base64,iVBORw0KGgo=">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <style>
        /* --- Base & Fluid Typography --- */
        html {
            /* Crée une taille de police de base qui s'adapte légèrement à la largeur de l'écran. */
            /* 1rem sera égal à cette valeur, rendant toute l'interface adaptable. */
            font-size: calc(14px + 0.2vw);
        }

        body {
            margin: 0;
            font-family: 'Share Tech Mono' , monospace;
            background-color: #0d0d0d;
            color: #00ffcc;
            overflow: hidden;
            font-size: 1rem; /* Définit la taille de police par défaut du corps à 1rem */
        }

        /* Overlay de saleté/moisissure */
        .grime-Overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            background: url('/static/texture_grime.png') repeat;
            opacity: 0.08;
            transition: opacity 0.8s ease-in-out;
            pointer-events: none;
            z-index: 3;
        }

        /* Structures mouvantes en fond */
        .moving-structure {
            position: fixed;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            background: url('/static/structure_moving.png') center center / cover no-repeat;
            opacity: 0.05;
            transition: opacity 0.8s ease-in-out;
            animation: drift 60s infinite linear;
            pointer-events: none;
            z-index: 1;
        }

        @keyframes drift {
            0% { transform: translate(0, 0) scale(1); }
            50% { transform: translate(-1vw, 0.5vh) scale(1.05); } /* Rendu relatif à la taille de l'écran */
            100% { transform: translate(0, 0) scale(1); }
        }

        /* Main container for the whole page content */
        .main-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            max-height: 100vh;
            padding: 2vh 2vw 2vh 8vw; /* Padding vertical relatif à la hauteur de l'écran */
            box-sizing: border-box;
            position: relative; /* Pour positionner les éléments en overlay */
        }

        /* Container for the side UI elements to align them perfectly */
        .side-ui-container {
            position: absolute;
            top: 50%;
            left: 3vw; /* Adjust horizontal position of the whole block */
            transform: translateY(-50%);
            display: flex;
            align-items: center; /* This is the key to vertical alignment */
            gap: 1.5vw; /* Space between button and title */
        }

        /* NOUVEAU : Indicateur de statut VPN */
        #vpn-status-indicator {
            font-size: 1.5rem;
            cursor: default;
            transition: all 0.3s ease;
            text-shadow: 0 0 0 transparent;
            /* Placé sous le bouton de navigation */
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-top: 0.5rem;
        }
        #vpn-status-indicator.connected {
            color: #00ffcc;
            text-shadow: 0 0 8px rgba(0, 255, 204, 0.7);
            animation: pulse-vpn 2s infinite;
        }
        #vpn-status-indicator.disconnected { color: rgba(255, 85, 85, 0.7); }
        @keyframes pulse-vpn { 0% { opacity: 0.7; } 50% { opacity: 1; } 100% { opacity: 0.7; } }

        h1 {
            /* Taille de police fluide avec des limites min/max pour éviter les extrêmes */
            font-size: clamp(1.8rem, 4vw, 3.5rem);
            margin: 0;
            animation: glitch 2s infinite;
            transform: rotate(-90deg);
            pointer-events: none; /* Pour ne pas être cliquable */
        }

        @keyframes glitch {
            0%, 100% { 
                text-shadow: 2px 0 rgba(255, 0, 0, 0.7), -2px 0 rgba(0, 0, 255, 0.7); 
                transform: skewX(0);
            }
            49% { text-shadow: 2px 0 rgba(255, 0, 0, 0.7), -2px 0 rgba(0, 0, 255, 0.7); transform: skewX(0); }
            50% { 
                text-shadow: -5px 0 rgba(255, 0, 0, 0.7), 3px 0 rgba(0, 0, 255, 0.7);
                transform: skewX(-5deg);
            }
            51% { text-shadow: 2px 0 rgba(255, 0, 0, 0.7), -2px 0 rgba(0, 0, 255, 0.7); transform: skewX(0); }
        }

        /* NOUVEAU : Animation de flash pour la transition d'accès */
        @keyframes success-flash {
            0% { background-color: #0d0d0d; }
            50% { background-color: #00ffcc; }
            100% { background-color: #0d0d0d; }
        }

        @keyframes screen-shake {
            0%, 100% { transform: translate(0, 0); }
            10%, 30%, 50%, 70%, 90% { transform: translate(-2px, 2px); }
            20%, 40%, 60%, 80% { transform: translate(2px, -2px); }
        }
        .shake-effect { animation: screen-shake 0.3s; }

        /* --- CONFIGURATION FINALE DU TERMINAL D'ARRIÈRE-PLAN - NE PAS MODIFIER --- */
        /* Cette section définit l'apparence et le comportement du terminal. */
        /* Son opacité (invisible par défaut) est gérée par JS pour l'animation. */
        /* Il est non-interactif par défaut (pointer-events: none). */
        /* Cette configuration est validée et fonctionnelle. */
        /* Terminal window styles */
        #cyber-terminal {
            flex-grow: 1; /* Take up remaining vertical space */
            background: rgba(0, 10, 8, 0.4);
            border: 0 solid rgba(0, 255, 204, 0.2);
            border-radius: 0.25rem;
            overflow-y: auto;
            padding: 1rem;
            position: relative; 
            /* Le terminal est invisible par défaut et apparaît pendant l'animation de défilement. */
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            box-shadow: inset 0 0 1rem rgba(0, 255, 204, 0.1);
            font-size: 0.9rem;
            /* MODIFICATION : Rend le terminal complètement insensible aux clics et au scroll de la souris. */
            pointer-events: none;
        }
        /* --- FIN CONFIGURATION TERMINAL --- */

        /* Custom scrollbar for the terminal */
        #cyber-terminal::-webkit-scrollbar {
            width: 6px; /* Rendre la barre de défilement plus fine */
        }
        #cyber-terminal::-webkit-scrollbar-track {
            background: transparent;
        }
        /* La barre de défilement est toujours invisible car le terminal n'est pas interactif. */
        #cyber-terminal::-webkit-scrollbar-thumb {
            background-color: transparent;
            border-radius: 0.25rem;
        }

        /* Content inside the terminal */
        #terminal-content {
            /* Opacité fixe pour un effet ambiant, plus de changement au survol. */
            opacity: 0.4;
        }

        #terminal-content p {
            margin: 0 0 0.2em 0; /* Marge inférieure pour un espacement lisible mais dense */
            white-space: pre-wrap; /* Respect whitespace and wrap lines */
            text-align: left; /* Align terminal text to the left */
            word-break: break-all;
        }

        /* Conditional syntax highlighting for logs */
        .log-critical { color: #ff5555; font-weight: bold; }
        .log-warning { color: #ffcc00; }
        .log-hex { color: #999; }
        .log-symbol { color: #80ffff; }

        .level-header {
            color: #ffff00; /* Yellow to stand out */
            margin: 1.5rem 0;
            letter-spacing: 0.15em; /* Relatif à la taille de la police de l'élément */
            position: relative; /* Contexte de positionnement pour le bouton d'accès */
            /* MODIFICATION : Utilisation de Flexbox pour un alignement parfait */
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1rem; /* Espace entre le titre et le bouton */
        }

        /* NOUVEAU: Style pour le bouton d'accès à côté du titre du niveau */
        .access-level-btn {
            background: transparent;
            border: 1px solid #ff33ff;
            color: #ff33ff;
            font-family: inherit;
            font-size: 0.8rem;
            padding: 0.2rem 0.5rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .access-level-btn:hover {
            background: rgba(255, 51, 255, 0.1);
            box-shadow: 0 0 8px rgba(255, 51, 255, 0.4);
        }

        .level-header.typing::after {
            content: '█';
            animation: blink 1s step-end infinite;
        }
        
        @keyframes blink {
            from, to { opacity: 1; }
            50% { opacity: 0; }
        }

        /* --- Navigation Menu Styles --- */
        .scroll-control {
            position: relative; /* It's now a flex item, so its position is relative to the flex container */
        }

        .scroll-btn {
            background: none;
            border: none;
            color: #00ffcc;
            /* La taille est maintenant contrôlée par l'icône SVG */
            cursor: pointer;
            transition: all 0.3s ease;
            padding: 0;
            line-height: 0; /* Assure que le bouton s'ajuste à la hauteur de l'icône */
        }

        .scroll-btn svg {
            width: 2.5rem;
            height: 2.5rem;
            display: block;
        }

        .scroll-btn:hover {
            color: #ff33ff;
            text-shadow: 0 0 8px #ff33ff;
        }

        .context-menu {
            position: absolute;
            top: 120%;
            left: 0;
            background: rgba(13, 13, 13, 0.95);
            border: 1px solid #00ffcc; /* 1px est acceptable pour une bordure fine et nette */
            border-radius: 0.25rem;
            padding: 0.75rem;
            min-width: 16rem; /* Augmentation de la largeur minimale */
            /* ADAPTATION : La largeur maximale s'adapte à la fenêtre pour éviter le débordement. */
            max-width: calc(100vw - 6vw); /* 100% de la largeur de la fenêtre moins la marge gauche (3vw) et une marge de sécurité à droite (3vw). */
            display: none;
            flex-direction: column;
            gap: 0.6rem; /* Léger agrandissement de l'espace entre les items */
            /* --- CONFIGURATION FINALE DU MENU - NE PAS MODIFIER --- */
            /* La hauteur maximale (max-height) est calculée pour éviter que le menu ne sorte de l'écran par le bas. */
            /* Le défilement interne (overflow-y) est activé si le contenu dépasse cette hauteur. */
            /* Cette configuration est validée et fonctionnelle. */
            max-height: 45vh;
            overflow-y: auto; /* Ajoute une barre de défilement si le contenu dépasse max-height. */
            /* --- FIN CONFIGURATION FINALE DU MENU --- */
            z-index: 1000;
            box-shadow: 0 0 15px rgba(0, 255, 204, 0.3);
            backdrop-filter: blur(5px);
            box-sizing: border-box; /* IMPORTANT: Assure que padding/border sont inclus dans la largeur totale */
        }

        /* Scrollbar pour le menu contextuel, si nécessaire (copié du terminal) */
        .context-menu::-webkit-scrollbar {
            width: 6px;
        }
        .context-menu::-webkit-scrollbar-track {
            background: transparent;
        }
        .context-menu::-webkit-scrollbar-thumb {
            background-color: rgba(0, 255, 204, 0.4);
            border-radius: 0.25rem;
        }

        .scroll-control.active .context-menu {
            display: flex;
            animation: menuAppear 0.3s ease;
        }

        @keyframes menuAppear {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .menu-item {
            padding: 0.75rem 1rem; /* Augmentation du padding pour plus d'aisance */
            color: #00ffcc;
            font-size: 0.9rem;            line-height: 1.3; /* Un peu plus d'espace pour la description */
            cursor: pointer;
            border-radius: 0.2rem;
            transition: all 0.2s ease;
            box-sizing: border-box; /* Cohérence pour le calcul de la taille */
            overflow-wrap: break-word; /* Permet au texte de se couper pour éviter le débordement */
        }

        /* Utilise un pseudo-élément pour afficher la description en sous-titre */
        .menu-item::after {
            content: attr(data-description); /* Récupère le texte de l'attribut data-description */
            display: block; /* Affiche sur une nouvelle ligne */
            font-size: 0.75em; /* Police plus petite pour le sous-titre */
            color: rgba(0, 255, 204, 0.7); /* Couleur légèrement atténuée */
            margin-top: 0.2em;
            white-space: normal; /* Permet au texte de passer à la ligne si besoin */
            pointer-events: none; /* S'assure que le sous-titre n'interfère pas avec les clics */
        }

        .menu-item:hover {
            background: rgba(0, 255, 204, 0.2);
        }

        .menu-item:active {
            background: rgba(0, 255, 204, 0.3);
        }

        /* --- Modal Styles --- */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        .modal-content {
            background: #0d0d0d;
            border: 1px solid #ff33ff;
            padding: 2rem;
            border-radius: 0.25rem;
            text-align: center;
            box-shadow: 0 0 25px rgba(255, 51, 255, 0.4);
            animation: menuAppear 0.5s ease;
        }
        .modal-content.shake-effect {
            animation: screen-shake 0.4s;
        }
        .modal-content h2 { color: #ff33ff; margin-top: 0; }
        .modal-content p { color: rgba(0, 255, 204, 0.8); }
        .modal-content input {
            background: rgba(0, 0, 0, 0.5); border: 1px solid rgba(0, 255, 204, 0.3);
            color: #00ffcc; font-family: inherit; font-size: 1.2rem;
            padding: 0.5rem; text-align: center; margin: 1rem 0;
        }
        .modal-actions { display: flex; gap: 1rem; justify-content: center; margin-top: 1rem; }
        .modal-actions button {
            padding: 0.5rem 1.5rem; font-family: inherit; font-size: 1rem;
            cursor: pointer; border-radius: 0.25rem; transition: all 0.2s ease;
        }
        #bunker-cancel-btn { background: transparent; border: 1px solid #ff5555; color: #ff5555; }
        #bunker-cancel-btn:hover { background: rgba(255, 85, 85, 0.1); }
        #bunker-submit-btn { background: #00ffcc; border: 1px solid #00ffcc; color: #0d0d0d; }
        #bunker-submit-btn:hover { box-shadow: 0 0 15px rgba(0, 255, 204, 0.7); }

        /* --- Media Queries for Responsiveness --- */
        @media (min-width: 2200px) {
            /* On very wide screens, prevent the terminal from becoming too wide for readability. */
            /* We constrain the main container and center it. */
            .main-container {
                max-width: 2000px;
                margin-left: auto;
                margin-right: auto;
            }
        }

        /* --- Style du Bouton Configurateur --- */
        #config-button {
            position: fixed;
            bottom: 2vh;
            right: 2vw;
            color: rgba(0, 255, 204, 0.6);
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 10;
            letter-spacing: 0.1em;
        }
        #config-button:hover {
            color: #ff33ff;
            text-shadow: 0 0 8px #ff33ff;
        }
    </style>
</head>
<body>
    <!-- Eléments Visuels -->
    <div class="moving-structure"></div>
    <div class="grime-Overlay"></div>

    <!-- Ambience sonore -->
    <audio autoplay loop>
        <source src="/static/Ressources/ambiance_sonore.mp3" type="audio/mpeg">
        pilotes/चालक audio Испорченный/corrupted
    </audio>
    <!-- NOUVEAU: Son pour l'animation de défilement -->
    <audio id="scroll-whoosh-sound" src="/static/Ressources/whoosh.mp3" preload="auto"></audio>

    <!-- Contenu -->
    <div class="main-container">
        <!-- Wrapper for side UI to ensure vertical alignment -->
        <div class="side-ui-container">
            <div class="scroll-control">
                <button id="scrollToggle" class="scroll-btn" aria-label="Ouvrir le menu de navigation">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 4L7 9h3v6H7l5 5 5-5h-3V9h3L12 4z"/></svg>
                </button>
                <!-- NOUVEAU : Indicateur VPN -->
                <div id="vpn-status-indicator" class="disconnected" title="VPN Déconnecté">🛡</div>
                <div id="contextMenu" class="context-menu">
                    <div class="menu-item" data-level="2" data-name="Visualiseur VPN" data-description="Visualisation en temps réel du routage VPN." data-url="/vpn_visualization" data-roles="concepteur,testeur">
                        NIVEAU 2 : Visualiseur VPN
                    </div>
                    <div class="menu-item" data-level="4" data-name="Analyseur" data-description="Supervision centralisée des extensions actives." data-url="/analyseur" data-roles="concepteur,testeur">
                        NIVEAU 4 : Analyseur
                    </div>
                    <div class="menu-item" data-level="23" data-name="Logicateur" data-description="Donnera accès à un chat avec ia intégrée." data-url="/logicateur">
                        NIVEAU 23 : Logicateur
                    </div>
                    <div class="menu-item" data-level="101" data-name="Bunker" data-description="Contiendra l'accès au dossier utilisateur et fichiers de configurations, tous fichiers relatifs aux données personnelles de l'user." data-url="/bunker">
                        NIVEAU 101 : Bunker
                    </div>
                    <div class="menu-item" data-level="303" data-name="Portail Conteneur" data-description="Donnera accès à la page des extensions." data-url="/portail_conteneur">
                        NIVEAU 303 : Portail Conteneur
                    </div>
                    <div class="menu-item" data-level="404" data-name="Accesseur" data-description="Est le landing niveau.">
                        NIVEAU 404 : Accesseur
                    </div>
                    <div class="menu-item" data-level="500" data-name="..." data-description="Emplacement réseau non alloué.">
                        NIVEAU 500 : ...
                    </div>
                    <!-- Séparateur pour les niveaux d'ambiance/non-alloués -->
                    <div style="height: 1px; background: rgba(0, 255, 204, 0.2); margin: 0.5rem 0;"></div>
                    <!-- Niveaux d'ambiance et non alloués, triés par ordre numérique -->
                    <div class="menu-item" data-level="77" data-name="..." data-description="Emplacement réseau non alloué.">
                        NIVEAU 77 : ...
                    </div>
                    <div class="menu-item" data-level="159" data-name="..." data-description="Emplacement réseau non alloué.">
                        NIVEAU 159 : ...
                    </div>
                    <div class="menu-item" data-level="241" data-name="Legislateur" data-description="Contiendra un accès à des rappels de lois EU et le disclaimer de l'app.">
                        NIVEAU 241 : Legislateur
                    </div>
                    <div class="menu-item" data-level="288" data-name="..." data-description="Emplacement réseau non alloué.">
                        NIVEAU 288 : ...
                    </div>
                    <div class="menu-item" data-level="341" data-name="..." data-description="Emplacement réseau non alloué.">
                        NIVEAU 341 : ...
                    </div>
                    <div class="menu-item" data-level="418" data-name="..." data-description="Emplacement réseau non alloué.">
                        NIVEAU 418 : ...
                    </div>
                </div>
            </div>
            <h1>[ NIVEAU 404 // ACCESSEUR ]</h1>
            <button id="main-access-btn" class="access-level-btn" style="display: none;">[ ACCÉDER ]</button>
        </div>

        <div id="cyber-terminal">
            <div id="terminal-content"></div>
        </div>
    </div>

    <!-- Bouton pour le configurateur (Niveau 0) -->
    <div id="config-button" data-level="0" data-name="Configurateur" data-url="/settings">
        [ NIVEAU 0 // CONFIGURATEUR ]
    </div>

    <script>
        // === DOM Elements ===
        const h1 = document.querySelector('h1');
        const mainAccessBtn = document.getElementById('main-access-btn');
        const terminal = document.getElementById('cyber-terminal');
        const terminalContent = document.getElementById('terminal-content');
        const contextMenu = document.getElementById('contextMenu');
        const scrollToggleBtn = document.getElementById('scrollToggle');
        const configButton = document.getElementById('config-button');
        const scrollControl = document.querySelector('.scroll-control');
        const scrollWhooshSound = document.getElementById('scroll-whoosh-sound');
        const vpnIndicator = document.getElementById('vpn-status-indicator');

        // === MODIFICATION ROBUSTE : Gestion du menu ===
        scrollToggleBtn.addEventListener('click', function(event) {
            event.stopPropagation();
            console.log("Clic sur le bouton de navigation détecté. Bascule du menu.");
            scrollControl.classList.toggle('active');
        });

        document.addEventListener('click', function(event) {
            // Vérifie si le clic est en dehors de la zone du menu ET du bouton
            const isClickOutside = !scrollControl.contains(event.target);
            
            if (scrollControl.classList.contains('active') && isClickOutside) {
                console.log("Clic en dehors du menu. Fermeture.");
                scrollControl.classList.remove('active');
            }
        });

        // Fermer le menu avec la touche Échap
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape' && scrollControl.classList.contains('active')) {
                scrollControl.classList.remove('active');
            }
        });

        // === Terminal Logic: The "Long Page" Illusion ===

        const levelMarkers = {}; // To store references to level headers


        // --- Data for log generation ---
        const multilingualKeywords = [
            // Anglais
            "INFECTION", "CONTAMINATION", "BREACH", "CORRUPTION", "OVERRIDE", "FAILOVER",
            "//ERROR//", "WARNING", "CRITICAL", "KERNEL PANIC", "EXECUTE", "INTRUSION",
            "QUARANTINE FAILED", "MALWARE DETECTED", "SYSTEM COMPROMISE", "DATA LEAK",
            "UNAUTHORIZED ACCESS", "ROOTKIT", "EXPLOIT", "ZERO-DAY",
            // Hindi
            "संक्रमण", "भंग", "चेतावनी", "सिस्टम विफल", "अनधिकृत पहुंच",
            // Japonais
            "感染", "破損", "警告", "システムエラー", "不正アクセス",
            // Ukrainien
            "зараження", "пошкодження", "попередження", "системний збій", "несанкціонований доступ",
            // Polonais
            "infekcja", "uszkodzony", "ostrzeżenie", "awaria systemu", "nieautoryzowany dostęp",
            // Arabe
            "إصابة", "تلف", "تحذير", "عطل في النظام", "وصول غير مصرح به"
        ];

        // Sets for faster lookup and classification
        const criticalKeywords = new Set(["INFECTION", "BREACH", "CORRUPTION", "FAILOVER", "//ERROR//", "CRITICAL", "KERNEL PANIC", "INTRUSION", "QUARANTINE FAILED", "MALWARE DETECTED", "SYSTEM COMPROMISE", "DATA LEAK", "UNAUTHORIZED ACCESS", "ROOTKIT", "EXPLOIT", "ZERO-DAY", "संक्रमण", "भंग", "системний збій", "зараження", "infekcja", "awaria systemu", "nieautoryzowany dostęp", "إصابة", "عطل في النظام", "وصول غير مصرح به", "破損", "システムエラー", "不正アクセス"]);
        const warningKeywords = new Set(["CONTAMINATION", "WARNING", "попередження", "ostrzeżenie", "تحذير", "警告", "uszkodzony", "تلف"]);

        const hexCodes = Array.from({length: 20}, () => '0x' + Math.floor(Math.random() * 0xFFFFFF).toString(16).toUpperCase().padStart(6, '0'));
        const unicodeChars = [
            // Caractères "linguistiques" pour brouiller les pistes
            "∀", "∃", "∧", "∨", "¬", "∈", "∉", "⊕", "⊗", // Logique mathématique
            "ᚠ", "ᚢ", "ᚦ", "ᚨ", "ᚱ", // Runes
            "☯", "☮", "☣", "☢", // Symboles
            "א", "ב", "ג", "د", "ذ", "ر", "ز", // Alphabets divers
            "ㄱ", "ㄴ", "ㄷ", "ㄹ", "ㅁ", "ㅂ", "ㅅ" // Hangul (Coréen)
        ];

        // --- New log generation function ---
        function generateRandomLine() {
            const numSegments = Math.floor(Math.random() * 4) + 2; // Entre 2 et 5 segments
            let messageParts = [];

            for (let i = 0; i < numSegments; i++) {
                const segmentType = Math.random();
                let segmentHTML = '';

                if (segmentType < 0.5) {
                    const keyword = multilingualKeywords[Math.floor(Math.random() * multilingualKeywords.length)];
                    if (criticalKeywords.has(keyword)) {
                        segmentHTML = `<span class="log-critical">${keyword}</span>`;
                    } else if (warningKeywords.has(keyword)) {
                        segmentHTML = `<span class="log-warning">${keyword}</span>`;
                    } else {
                        segmentHTML = keyword;
                    }
                } else if (segmentType < 0.7) {
                    const hex = hexCodes[Math.floor(Math.random() * hexCodes.length)];
                    segmentHTML = `<span class="log-hex">${hex}</span>`;
                } else if (segmentType < 0.9) {
                    const unicodeSeq = Array.from({length: Math.floor(Math.random() * 5) + 3}, () => unicodeChars[Math.floor(Math.random() * unicodeChars.length)]).join('');
                    segmentHTML = `<span class="log-symbol">${unicodeSeq}</span>`;
                } else {
                    const chaos = [multilingualKeywords[Math.floor(Math.random() * multilingualKeywords.length)], hexCodes[Math.floor(Math.random() * hexCodes.length)], unicodeChars[Math.floor(Math.random() * unicodeChars.length)]].sort(() => Math.random() - 0.5).join('');
                    segmentHTML = chaos;
                }
                messageParts.push(segmentHTML);
            }
            const separators = [' ', ':', '//', '||', '><', '##'];
            const chosenSeparator = separators[Math.floor(Math.random() * separators.length)];
            return messageParts.join(` ${chosenSeparator} `);
        }
        // Function to add a line to the terminal (without auto-scrolling)
        function addTerminalLine(text, className = '') {
            // REFACTORING : Cette fonction ne gère plus que les lignes de log (<p>).
            // La création des en-têtes (<div>) est maintenant gérée directement dans populateTerminal.
            const p = document.createElement('p');
            p.innerHTML = text; // innerHTML est nécessaire pour les spans de couleur.
            if (className) p.className = className;
            terminalContent.appendChild(p);
            return p;
        }

        // Pre-populates the terminal with a lot of content
        function populateTerminal(installedExtensions = []) {
            // Niveaux statiques et d'ambiance
            const baseLevels = [404, 2, 4, 23, 101, 241, 303, 500, 77, 159, 288, 341, 418];
            const linesPerLevel = 200;

            // --- REFACTORING : Logique de génération des niveaux rendue robuste ---
            // Au lieu de lire le DOM (ce qui est fragile), nous utilisons directement
            // la liste des extensions installées passée en argument.
            const extensionLevels = installedExtensions.map(ext => ext.level);

            // On combine les niveaux de base avec ceux des extensions pour avoir la liste complète
            // de tous les "conteneurs" à générer dans le terminal.
            const levelsToGenerate = [...baseLevels, ...extensionLevels];

            // Trier tous les niveaux par ordre décroissant pour un affichage cohérent dans le terminal
            levelsToGenerate.sort((a, b) => b - a);

            for (const level of levelsToGenerate) {
                // --- En-tête de DÉBUT (BEGIN) - Méthode programmatique robuste ---
                const beginHeader = document.createElement('div');
                beginHeader.className = 'level-header';
                beginHeader.id = `level-start-${level}`;
                beginHeader.dataset.level = level; // Stocker le niveau pour le retrouver

                // 1. Créer et ajouter le texte du titre dans un span.
                const textSpan = document.createElement('span');
                textSpan.textContent = `--- BEGIN TRANSMISSION // NIVEAU ${level} ---`;
                beginHeader.appendChild(textSpan);

                terminalContent.appendChild(beginHeader);

                levelMarkers[level] = beginHeader;

                // --- Génération des lignes de log ---
                for (let j = 0; j < linesPerLevel; j++) addTerminalLine(generateRandomLine());

                // --- En-tête de FIN (END) ---
                const endHeader = document.createElement('div');
                endHeader.className = 'level-header';
                endHeader.textContent = `--- END TRANSMISSION // NIVEAU ${level} ---`;
                terminalContent.appendChild(endHeader);
            }
        }

        // --- Typewriter effect for headers ---
        function typewriterEffect(element, onComplete) {
            const originalText = element.textContent;
            let i = 0;
            element.textContent = '';
            element.classList.add('typing'); // Add class for cursor

            function type() {
                if (i < originalText.length) {
                    element.textContent += originalText.charAt(i);
                    i++;
                    setTimeout(type, 50); // Typing speed (50ms)
                } else {
                    element.classList.remove('typing'); // Remove cursor
                    if (onComplete) onComplete();
                }
            }
            type();
        }

        /* --- CONFIGURATION FINALE DE L'ANIMATION DE DÉFILEMENT - NE PAS MODIFIER --- */
        /* Ce moteur gère l'animation de défilement personnalisée du terminal. */
        /* La durée (passée en argument, actuellement 2500ms) et la fonction d'easing (easeOutQuint) */
        /* ont été choisies pour un effet de "freinage" prononcé et ne doivent pas être changées. */
        /* La fonction est appelée par triggerScrollAvalanche. */
        // --- Custom Scrolling Animation Engine ---
        function customScrollTo(targetPosition, duration = 1500, onComplete) {
            // --- MODIFICATION : Bloquer le défilement utilisateur ---
            terminal.style.overflowY = 'hidden';

            const startPosition = terminal.scrollTop;
            const distance = targetPosition - startPosition;
            let startTime = null;

            // Easing function with a strong "braking" effect at the end (starts fast, ends slow).
            function easeOutQuint(t, b, c, d) {
                t /= d;
                t--;
                return c * (t * t * t * t * t + 1) + b;
            }

            function animation(currentTime) {
                if (startTime === null) startTime = currentTime;
                const timeElapsed = currentTime - startTime;
                const run = easeOutQuint(timeElapsed, startPosition, distance, duration);
                terminal.scrollTop = run;
                if (timeElapsed < duration) {
                    requestAnimationFrame(animation);
                } else {
                    terminal.scrollTop = targetPosition; // Ensure it lands perfectly
                    // --- MODIFICATION : Réactiver le défilement utilisateur ---
                    terminal.style.overflowY = 'auto';
                    if (onComplete) onComplete(); // Execute callback when finished
                }
            }

            requestAnimationFrame(animation);
        }
        /* --- FIN CONFIGURATION ANIMATION --- */

        // Fonction pour jouer un son de manière fiable
        function playSound(audioElement) {
            if (audioElement) {
                audioElement.currentTime = 0;
                audioElement.play().catch(e => console.error("Erreur de lecture audio:", e));
            }
        }

        // --- LOGIQUE DE NAVIGATION DU MENU - NE PAS MODIFIER ---
        // Cette section gère la sélection d'un niveau, l'animation de défilement,
        // et l'affichage conditionnel du bouton "ACCÉDER".
        // Le flux a été validé : sélection -> animation -> affichage bouton.
        // Toute modification risque de casser la séquence.
        // The "Avalanche" effect with the new mechanics
        function triggerScrollAvalanche(level, onComplete) {
            const targetMarker = levelMarkers[level];
            if (!targetMarker) return;

            // Rendre le terminal visible pour l'animation de défilement.
            terminal.style.opacity = 1;

            const targetPosition = targetMarker.offsetTop - 15; // -15px for padding            
            terminal.classList.add('shake-effect'); // Shake the terminal

            playSound(scrollWhooshSound); // Jouer le son de transition

            // Start custom scroll, and execute callback on completion
            customScrollTo(targetPosition, 2500, () => {
                // Scroll is finished. Fade out the decor and terminal.
                if (onComplete) onComplete();
            });

            setTimeout(() => terminal.classList.remove('shake-effect'), 800);
        }

        // Gère la navigation vers une autre page (appelé par le bouton ACCÉDER)
        function handleNavigation(level, url) {
            if (!url) return;

            // Déclencher le flash AVANT la navigation
            document.body.style.animation = "success-flash 0.8s forwards";
            
            // Naviguer après la fin de l'animation pour que le flash soit visible
            setTimeout(() => {
                window.location.href = url;
            }, 800);
        }
        // --- FIN DE LA LOGIQUE DE NAVIGATION ---

        // Le clic sur un item du menu ne fait que FAIRE DÉFILER le terminal
        contextMenu.addEventListener('click', (event) => {
            const menuItem = event.target.closest('.menu-item');
            if (menuItem) {
                event.stopPropagation(); // Empêche le menu de se fermer à cause d'un autre listener
                
                const level = menuItem.dataset.level;
                const name = menuItem.dataset.name || '???';
                const url = menuItem.dataset.url;

                scrollControl.classList.remove('active'); // Fermer le menu
                // Rendre le terminal visible pour l'animation
                terminal.style.opacity = 1;
                h1.textContent = `[ NIVEAU ${level} // ${name.toUpperCase()} ]`;

                // Afficher ou cacher le bouton d'accès principal
                if (url) {
                    mainAccessBtn.style.display = 'block';
                    mainAccessBtn.dataset.url = url;
                    mainAccessBtn.dataset.level = level;
                } else {
                    mainAccessBtn.style.display = 'none';
                }

                // Lancer l'animation de défilement, sans callback de navigation.
                // Le terminal restera visible après.
                triggerScrollAvalanche(level, null);
            }
        });

        configButton.addEventListener('click', function() {
            const url = this.dataset.url;
            if (url) {
                window.location.href = url;
            }
        });

        // Le clic sur le bouton d'accès principal déclenche la navigation
        mainAccessBtn.addEventListener('click', function() {
            const level = this.dataset.level;
            const url = this.dataset.url;
            handleNavigation(level, url);
        });

        // --- NOUVEAU : Construction dynamique du menu ---
        async function buildDynamicMenu() {
            try {
                const result = await window.pywebview.api.get_installed_extensions();
                if (result.status === 'success' && result.extensions.length > 0) {
                    const separator = document.createElement('div');
                    separator.style.height = '1px';
                    separator.style.background = 'rgba(0, 255, 204, 0.2)';
                    separator.style.margin = '0.5rem 0';
                    contextMenu.appendChild(separator);

                    // Tri des extensions par niveau pour un affichage ordonné
                    result.extensions.sort((a, b) => a.level - b.level);

                    result.extensions.forEach(ext => {
                        const menuItem = document.createElement('div');
                        menuItem.className = 'menu-item';
                        menuItem.dataset.level = ext.level;
                        menuItem.dataset.name = ext.name;
                        menuItem.dataset.description = ext.description;
                        menuItem.dataset.url = ext.url;
                        menuItem.textContent = `NIVEAU ${ext.level} : ${ext.name}`;
                        
                        contextMenu.appendChild(menuItem);
                    });
                    return result.extensions; // Retourne les données pour la prochaine étape
                }
            } catch (e) {
                console.error("Impossible de charger les extensions installées:", e);
                return []; // Retourne un tableau vide en cas d'erreur
            }
        }

        // --- NOUVEAU : Logique de l'indicateur VPN ---
        function updateVpnIndicator(data) {
            if (!vpnIndicator || !data) return;

            const isConnected = data.is_connected;
            vpnIndicator.classList.toggle('connected', isConnected);
            vpnIndicator.classList.toggle('disconnected', !isConnected);
            vpnIndicator.title = isConnected 
                ? `VPN Connecté (IP: ${data.virtual_ip || 'N/A'})` 
                : 'VPN Déconnecté';
        }

        // --- NOUVEAU : Filtrage du menu par rôle ---
        function filterMenuByRole() {
            // Rôle par défaut 'lambda' si non connecté ou si la session est vide
            const userRole = sessionStorage.getItem('userRole') || 'lambda';
            console.log(`Filtrage du menu pour le rôle : ${userRole}`);

            const menuItems = document.querySelectorAll('#contextMenu .menu-item');

            menuItems.forEach(item => {
                const requiredRoles = item.dataset.roles;
                if (requiredRoles) {
                    const rolesArray = requiredRoles.split(',');
                    if (!rolesArray.includes(userRole)) {
                        item.style.display = 'none';
                    }
                }
            });
        }

        // On page load, populate and set initial view
        window.addEventListener('pywebviewready', () => {
            function setupInitialView(initialLevel) {
                const initialMenuItem = document.querySelector(`.menu-item[data-level="${initialLevel}"]`);
                const initialName = initialMenuItem ? initialMenuItem.dataset.name : 'ACCESSEUR';
                const initialUrl = initialMenuItem ? initialMenuItem.dataset.url : null;
                h1.textContent = `[ NIVEAU ${initialLevel} // ${initialName.toUpperCase()} ]`;

                if (initialUrl) {
                    mainAccessBtn.style.display = 'block';
                    mainAccessBtn.dataset.url = initialUrl;
                    mainAccessBtn.dataset.level = initialLevel;
                } else {
                    mainAccessBtn.style.display = 'none';
                }

                const initialMarker = levelMarkers[initialLevel];
                if (initialMarker) {
                    terminal.scrollTop = initialMarker.offsetTop - 15;
                }
            }

            async function initialize() {
                // 1. On filtre les éléments statiques du menu en fonction du rôle de l'utilisateur.
                filterMenuByRole();

                // 2. On charge les extensions installées et on les ajoute au menu. On récupère leurs données.
                const installedExtensions = await buildDynamicMenu();
                // 3. On génère le contenu du terminal en lui passant explicitement les données des extensions.
                populateTerminal(installedExtensions);

                let initialLevel;
                try {
                    initialLevel = {{ start_level | tojson }};
                } catch (e) {
                    initialLevel = 404;
                }
                setupInitialView(initialLevel);
            }

            initialize();

            // Écouter les mises à jour du VPN en temps réel
            window.pywebview.events.vpn_status_update.connect(updateVpnIndicator);
            window.pywebview.api.get_vpn_status().then(updateVpnIndicator); // État initial
        });
    </script>
</body>
</html>