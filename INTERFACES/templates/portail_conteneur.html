<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Mégastructure // Portail Conteneur</title>
    <link rel="icon" href="data:;base64,iVBORw0KGgo=">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <style>
        /* --- Base Styles (copied for consistency) --- */
        html { font-size: calc(14px + 0.2vw); }
        body { margin: 0; font-family: 'Share Tech Mono', monospace; background-color: #0d0d0d; color: #00ffcc; overflow: hidden; font-size: 1rem; }
        .grime-Overlay, .moving-structure { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; }
        .grime-Overlay { background: url('/static/texture_grime.png') repeat; opacity: 0.08; z-index: 3; }
        .moving-structure { background: url('/static/structure_moving.png') center center / cover no-repeat; opacity: 0.05; animation: drift 60s infinite linear; z-index: 1; }
        @keyframes drift { 0% { transform: translate(0, 0) scale(1); } 50% { transform: translate(-1vw, 0.5vh) scale(1.05); } 100% { transform: translate(0, 0) scale(1); } }
        @keyframes glitch { 0%, 100% { text-shadow: 0.05em 0 red, -0.05em 0 blue; } 50% { text-shadow: -0.05em 0 red, 0.05em 0 blue; } }

        /* --- Page Specific Styles --- */
        .portail-container { position: relative; z-index: 4; padding: 3vh 4vw; box-sizing: border-box; height: 100vh; display: flex; flex-direction: column; }
        h1 { font-size: clamp(1.5rem, 3vw, 2.5rem); margin: 0 0 1.5rem 0; animation: glitch 2s infinite; text-align: center; }
        
        .main-grid {
            display: grid;
            grid-template-columns: 1fr 400px; /* Main grid and details panel */
            gap: 1.5rem;
            flex-grow: 1;
            height: calc(100% - 8rem); /* Adjust based on header/footer height */
        }

        #conteneur-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 0.5rem;
            overflow-y: auto;
            padding: 0.5rem;
        }
        
        /* Custom Scrollbar */
        #conteneur-grid::-webkit-scrollbar { width: 6px; }
        #conteneur-grid::-webkit-scrollbar-track { background: transparent; }
        #conteneur-grid::-webkit-scrollbar-thumb { background-color: rgba(0, 255, 204, 0.4); border-radius: 0.25rem; }

        .conteneur-cell {
            border: 1px solid rgba(0, 255, 204, 0.2);
            height: 45px; /* Rendre les cellules rectangulaires et plus basses */
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }
        .conteneur-cell:hover, .conteneur-cell.active {
            background: rgba(0, 255, 204, 0.1);
            border-color: #00ffcc;
        }
        .conteneur-cell.glitching {
            color: #ff33ff;
            text-shadow: 0 0 8px #ff33ff;
        }

        /* Type styles */
        .conteneur-cell.type-furtif { border-style: dashed; }
        .conteneur-cell.type-blindé {
            border-width: 2px;
            border-color: #ff5555;
            color: #ff5555;
        }
        .conteneur-cell.type-blindé:hover, .conteneur-cell.type-blindé.active {
            background: rgba(255, 85, 85, 0.1);
            border-color: #ff5555;
        }

        /* Status styles */
        .conteneur-cell.status-inerte { color: rgba(0, 255, 204, 0.4); cursor: default; }
        .conteneur-cell.status-inerte:hover { background: transparent; border-color: rgba(0, 255, 204, 0.2); }
        .conteneur-cell.status-bloqué { background: rgba(50,50,50,0.5); color: #666; border-color: #444; cursor: not-allowed; }
        .conteneur-cell.status-contaminé { color: #ffff00; border-color: #ffff00; animation: glitch 0.5s infinite; }

        /* --- NOUVEAU : Effet de "purulence" au survol --- */
        @keyframes purulence {
            0% { content: "01_ERR# 感染 ⏧☣"; opacity: 0.7; transform: skewX(-10deg); text-shadow: 0 0 3px red; }
            25% { content: "CORRUPT_DATA ☢︎☠︎"; opacity: 0.8; transform: skewX(10deg); }
            50% { content: "SYS_FAULT 警告 ∰"; opacity: 0.6; transform: translate(3px, -3px); text-shadow: 0 0 3px blue; }
            75% { content: "##_BREACH_## ∰☣"; opacity: 0.9; transform: skewY(-10deg); }
            100% { content: "DATA_PURGE ☢︎☠︎"; opacity: 0.7; transform: translate(-3px, 3px); }
        }
        .conteneur-cell.status-contaminé:hover::after {
            content: '';
            position: absolute;
            top: -5px; left: -5px; right: -5px; bottom: -5px;
            background: rgba(255, 255, 0, 0.15);
            backdrop-filter: blur(3px);
            color: #ffff00;
            font-size: 0.7rem;
            text-align: left;
            padding: 2px;
            overflow: hidden;
            animation: purulence 0.08s infinite;
            z-index: 5;
            border: 1px solid rgba(255, 0, 0, 0.6);
            box-shadow: inset 0 0 10px rgba(255, 255, 0, 0.5);
        }

        /* --- NOUVEAU : Riddle Keyboard Styles --- */
        .riddle-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(13, 13, 13, 0.95);
            backdrop-filter: blur(5px);
            z-index: 10;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 1rem;
            animation: riddleFadeIn 0.5s ease;
        }
        @keyframes riddleFadeIn { from { opacity: 0; } to { opacity: 1; } }

        .riddle-box {
            width: 350px;
            height: 350px;
            border: 1px solid #ff5555;
            background: rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
            padding: 1rem;
            box-shadow: 0 0 20px rgba(255, 85, 85, 0.5);
        }

        .riddle-display {
            height: 50px;
            background: rgba(0,0,0,0.7);
            border: 1px solid rgba(255, 85, 85, 0.4);
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            color: #ff5555;
            letter-spacing: 0.5em;
        }
        .riddle-display.error { animation: shake 0.3s; }
        @keyframes shake { 10%, 90% { transform: translate3d(-1px, 0, 0); } 20%, 80% { transform: translate3d(2px, 0, 0); } 30%, 50%, 70% { transform: translate3d(-4px, 0, 0); } 40%, 60% { transform: translate3d(4px, 0, 0); } }

        .riddle-keyboard { flex-grow: 1; display: grid; grid-template-columns: repeat(6, 1fr); grid-template-rows: repeat(7, 1fr); gap: 0.5rem; }

        .riddle-key { border: 1px solid rgba(255, 85, 85, 0.3); color: rgba(255, 85, 85, 0.8); display: flex; justify-content: center; align-items: center; font-size: 1.2rem; cursor: pointer; transition: all 0.2s ease; }
        .riddle-key:hover { background: rgba(255, 85, 85, 0.2); color: #ff5555; border-color: #ff5555; }
        .riddle-key.special { font-size: 1rem; color: #ffff00; border-color: rgba(255, 255, 0, 0.5); }

        /* Details Panel */
        #details-panel {
            background: rgba(0, 10, 8, 0.4);
            border: 1px solid rgba(0, 255, 204, 0.2);
            border-radius: 0.25rem;
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            color: rgba(255, 255, 255, 0.85);
            position: relative; /* Needed for the riddle overlay */
        }
        #details-panel .placeholder { text-align: center; color: rgba(255,255,255,0.4); margin: auto; }
        #details-panel h2 { font-size: 1.5rem; color: #ff33ff; margin: 0; letter-spacing: 0.1em; }
        #details-panel .version { font-size: 0.8rem; color: rgba(0, 255, 204, 0.5); }
        #details-panel .description { font-size: 0.9rem; flex-grow: 1; margin: 1rem 0; }
        #details-panel .footer { font-size: 0.8rem; color: rgba(0, 255, 204, 0.6); }
        #details-panel input[type="text"] {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(0, 255, 204, 0.3);
            color: #00ffcc;
            font-family: inherit;
            font-size: 0.9rem;
            padding: 0.5rem;
            border-radius: 0.2rem;
            flex-grow: 1;
        }
        #details-panel .author { font-style: italic; }
        #details-panel .type { text-transform: uppercase; letter-spacing: 0.1em; }

        .card-actions { margin-top: auto; display: flex; justify-content: flex-end; align-items: center; gap: 1rem; }
        .action-btn { padding: 0.5rem 1.5rem; font-family: inherit; font-size: 0.9rem; cursor: pointer; border-radius: 0.25rem; transition: all 0.2s ease; border: 1px solid; }
        .install-btn { background: #00ffcc; color: #0d0d0d; border-color: #00ffcc; }
        .install-btn:hover { box-shadow: 0 0 15px rgba(0, 255, 204, 0.7); }
        .uninstall-btn { background: transparent; color: #ff5555; border-color: #ff5555; }
        .uninstall-btn:hover { background: rgba(255, 85, 85, 0.1); }
        .installed-info { color: #00ffcc; font-style: italic; }
        
        #back-btn { position: fixed; bottom: 2vh; right: 2vw; color: rgba(0, 255, 204, 0.6); font-size: 0.8rem; cursor: pointer; transition: all 0.3s ease; z-index: 10; letter-spacing: 0.1em; }
        #back-btn:hover { color: #ff33ff; text-shadow: 0 0 8px #ff33ff; }

        /* Notification styles */
        #notification-container { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); z-index: 9999; display: flex; flex-direction: column; align-items: center; gap: 10px; }
        .notification { padding: 10px 20px; background-color: rgba(0, 255, 204, 0.9); color: #0d0d0d; border-radius: 3px; box-shadow: 0 2px 10px rgba(0,0,0,0.5); font-size: 0.9rem; opacity: 1; transition: opacity 0.5s ease; }
        .notification.error { background-color: rgba(255, 51, 255, 0.9); }
    </style>
</head>
<body>
    <div class="moving-structure"></div>
    <div class="grime-Overlay"></div>
    <div id="notification-container"></div>

    <div class="portail-container">
        <h1>[ NIVEAU 303 // PORTAIL CONTENEUR ]</h1>
        <div class="main-grid">
            <div id="conteneur-grid">
                <!-- Les cellules de la grille seront injectées ici -->
            </div>
            <div id="details-panel">
                <!-- Les détails du conteneur sélectionné apparaîtront ici -->
            </div>
        </div>
    </div>

    <div id="back-btn" onclick="window.location.href='/terminaux.html'">[ RETOUR ]</div>

    <script>
        window.addEventListener('pywebviewready', () => {
            const conteneurGrid = document.getElementById('conteneur-grid');
            const detailsPanel = document.getElementById('details-panel');
            let installedExtensions = {};
            let allConteneurs = [];
            let animationInterval = null;
            let riddleInterval = null;
            const CORRECT_RIDDLE_ANSWER = "open";


            function showNotification(message, type = 'info', duration = 4000) {
                const container = document.getElementById('notification-container');
                if (!container) return;
                const notif = document.createElement('div');
                notif.className = `notification ${type}`;
                notif.textContent = message;
                container.appendChild(notif);
                setTimeout(() => {
                    notif.style.opacity = '0';
                    notif.addEventListener('transitionend', () => notif.remove());
                }, duration);
            }

            function showRiddleKeyboard(conteneur) {
                // Clear any existing riddle UI
                const existingOverlay = detailsPanel.querySelector('.riddle-overlay');
                if (existingOverlay) existingOverlay.remove();
                if (riddleInterval) clearInterval(riddleInterval);

                // Create overlay
                const overlay = document.createElement('div');
                overlay.className = 'riddle-overlay';
                overlay.innerHTML = `
                    <div class="riddle-box">
                        <div class="riddle-display" id="riddle-display"></div>
                        <div class="riddle-keyboard" id="riddle-keyboard"></div>
                    </div>
                `;
                detailsPanel.appendChild(overlay);

                const keyboard = document.getElementById('riddle-keyboard');
                const display = document.getElementById('riddle-display');
                let userInput = "";

                const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'.split('');
                const specialKeys = ['⌫', 'CLR']; // Backspace and Clear

                function shuffleAndRenderKeyboard() {
                    // Fisher-Yates shuffle
                    let shuffledChars = [...characters];
                    for (let i = shuffledChars.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [shuffledChars[i], shuffledChars[j]] = [shuffledChars[j], shuffledChars[i]];
                    }
                    
                    const gridChars = shuffledChars.slice(0, 42 - specialKeys.length);
                    const finalKeys = [...gridChars, ...specialKeys];

                    for (let i = finalKeys.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [finalKeys[i], finalKeys[j]] = [finalKeys[j], finalKeys[i]];
                    }

                    keyboard.innerHTML = '';
                    finalKeys.forEach(char => {
                        const key = document.createElement('div');
                        key.className = 'riddle-key';
                        key.textContent = char;
                        if (specialKeys.includes(char)) {
                            key.classList.add('special');
                        }
                        keyboard.appendChild(key);
                    });
                }

                function handleKeyPress(key) {
                    display.classList.remove('error');
                    if (key === '⌫') { userInput = userInput.slice(0, -1); } 
                    else if (key === 'CLR') { userInput = ""; } 
                    else { if (userInput.length < 4) { userInput += key; } }
                    display.textContent = userInput;

                    if (userInput.length === 4) {
                        if (userInput.toLowerCase() === CORRECT_RIDDLE_ANSWER) {
                            showNotification('Protocole déchiffré. Accès autorisé.', 'info');
                            conteneur.unlocked = true;
                            if (riddleInterval) clearInterval(riddleInterval);
                            overlay.remove();
                            renderDetails(conteneur);
                        } else {
                            showNotification('Séquence invalide. Réinitialisation...', 'error');
                            display.classList.add('error');
                            setTimeout(() => { userInput = ""; display.textContent = ""; display.classList.remove('error'); }, 500);
                        }
                    }
                }

                keyboard.addEventListener('click', (e) => {
                    if (e.target.classList.contains('riddle-key')) { handleKeyPress(e.target.textContent); }
                });

                shuffleAndRenderKeyboard();
                riddleInterval = setInterval(shuffleAndRenderKeyboard, 60000);
            }

            function renderDetails(conteneur) {
                if (riddleInterval) { clearInterval(riddleInterval); riddleInterval = null; }

                if (!conteneur) {
                    detailsPanel.innerHTML = `<div class="placeholder"><p>SÉLECTIONNEZ UN CONTENEUR</p></div>`;
                    return;
                }

                // NOUVEAU : Gérer les conteneurs blindés avec une énigme
                if (conteneur.type === 'blindé' && !conteneur.unlocked) {
                    detailsPanel.innerHTML = '';
                    showRiddleKeyboard(conteneur);
                    return;
                }

                const isExtension = conteneur.type === 'extension';
                const isInstalled = isExtension && installedExtensions[conteneur.name];
                let actionsHtml = '';

                if (isExtension) {
                    if (isInstalled) {
                        const level = installedExtensions[conteneur.name].level;
                        actionsHtml = `
                            <div class="card-actions">
                                <span class="installed-info">Installé au Niveau ${level}</span>
                                <button class="action-btn uninstall-btn" data-name="${conteneur.name}">Désinstaller</button>
                            </div>`;
                    } else {
                        actionsHtml = `
                            <div class="card-actions">
                                <button class="action-btn install-btn" data-id="${conteneur.id}">Installer</button>
                            </div>`;
                    }
                }

                detailsPanel.innerHTML = `
                    <h2>${conteneur.name || 'Conteneur Anonyme'}</h2>
                    <span class="version">v${conteneur.version || '?.?'}</span>
                    <p class="description">${conteneur.description || 'Aucune description.'}</p>
                    <div class="footer">
                        <span class="author">Auteur: ${conteneur.author || 'Inconnu'}</span>
                        <span class="type">Type: ${conteneur.type || 'Indéfini'}</span>
                    </div>
                    ${actionsHtml}
                `;
            }

            function animateGrid() {
                if (animationInterval) clearInterval(animationInterval);
                
                const cells = Array.from(conteneurGrid.children);
                if (cells.length === 0) return;

                animationInterval = setInterval(() => {
                    for (let i = 0; i < 3; i++) { // Change 3 cells at a time for more activity
                        const randomCell = cells[Math.floor(Math.random() * cells.length)];
                        const originalId = randomCell.dataset.id.padStart(2, '0');
                        const randomGlitchNumber = Math.floor(Math.random() * 100).toString().padStart(2, '0');

                        randomCell.textContent = randomGlitchNumber;
                        randomCell.classList.add('glitching');

                        setTimeout(() => {
                            randomCell.textContent = originalId;
                            randomCell.classList.remove('glitching');
                        }, 150 + Math.random() * 200);
                    }
                }, 200);
            }

            async function renderPortail() {
                conteneurGrid.innerHTML = '<p>Synchronisation avec le réseau de conteneurs...</p>';
                renderDetails(null); // Clear details panel

                try {
                    // 1. Récupérer les extensions installées
                    const installedResult = await window.pywebview.api.get_installed_extensions();
                    if (installedResult.status === 'success') {
                        installedExtensions = installedResult.extensions.reduce((acc, ext) => {
                            acc[ext.name] = ext;
                            return acc;
                        }, {});
                    } else {
                        showNotification('Erreur de synchronisation des extensions installées.', 'error');
                    }

                    // 2. Récupérer tous les conteneurs disponibles
                    const conteneursResult = await window.pywebview.api.get_conteneurs();
                    if (conteneursResult.status !== 'success') {
                        conteneurGrid.innerHTML = `<p class="error">${conteneursResult.message}</p>`;
                        return;
                    }

                    conteneurGrid.innerHTML = ''; // Vider la grille
                    allConteneurs = conteneursResult.conteneurs;

                    // 3. Afficher chaque conteneur
                    if (allConteneurs.length === 0) {
                        conteneurGrid.innerHTML = '<p>Aucun conteneur détecté sur le réseau.</p>';
                        return;
                    }

                    allConteneurs.forEach(c => {
                        const cell = document.createElement('div');
                        cell.className = `conteneur-cell type-${c.type} status-${c.status}`;
                        cell.textContent = c.id.toString().padStart(2, '0');
                        cell.dataset.id = c.id;
                        conteneurGrid.appendChild(cell);
                    });

                    animateGrid();

                } catch (e) {
                    conteneurGrid.innerHTML = `<p class="error">Erreur de connexion au portail: ${e}</p>`;
                }
            }

            async function handleGridClick(event) {
                const cell = event.target.closest('.conteneur-cell');
                
                if (!cell) {
                    renderDetails(null);
                    conteneurGrid.querySelectorAll('.active').forEach(c => c.classList.remove('active'));
                    return;
                }

                // Ne rien faire pour les conteneurs inertes ou bloqués
                if (cell.classList.contains('status-inerte') || cell.classList.contains('status-bloqué')) {
                    // Clear details panel and any active riddle
                    renderDetails(null);
                    conteneurGrid.querySelectorAll('.active').forEach(c => c.classList.remove('active'));
                    return;
                }
                
                // Remove active class from all other cells
                conteneurGrid.querySelectorAll('.active').forEach(c => c.classList.remove('active'));
                cell.classList.add('active');

                const id = parseInt(cell.dataset.id, 10);
                const conteneur = allConteneurs.find(c => c.id === id);
                renderDetails(conteneur);
            }

            async function handleActionClick(event) {
                const installBtn = event.target.closest('.install-btn');
                const uninstallBtn = event.target.closest('.uninstall-btn');

                if (installBtn) {
                    installBtn.disabled = true;
                    const id = parseInt(installBtn.dataset.id, 10);
                    showNotification(`Installation de l'extension ID:${id}...`);
                    const result = await window.pywebview.api.install_extension(id);
                    if (result.status === 'success') {
                        showNotification(result.message, 'info');
                        await renderPortail(); // Recharger la liste
                    } else {
                        showNotification(result.message, 'error');
                        installBtn.disabled = false;
                    }
                }

                if (uninstallBtn) {
                    uninstallBtn.disabled = true;
                    const name = uninstallBtn.dataset.name;
                    showNotification(`Désinstallation de '${name}'...`);
                    const result = await window.pywebview.api.uninstall_extension(name);
                    if (result.status === 'success') {
                        showNotification(result.message, 'info');
                        await renderPortail(); // Recharger la liste
                    } else {
                        showNotification(result.message, 'error');
                        uninstallBtn.disabled = false;
                    }
                }
            }

            conteneurGrid.addEventListener('click', handleGridClick);
            detailsPanel.addEventListener('click', handleActionClick);
            renderPortail();
        });
    </script>
</body>
</html>